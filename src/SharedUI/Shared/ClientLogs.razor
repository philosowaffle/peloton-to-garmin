@using Serilog.Events
@inherits TracingComponentBase
@inject IApiClient _apiClient
@inject IHxMessengerService _toaster;
@inject IJSRuntime JS

<h3>Logs</h3>
<EditForm Model="@currentLogLevel">
    <div class="row">
        <div class="col-4">
            <HxSelect 
                Data="AvailablelogLevels"
                @bind-Value="currentLogLevel"
                TextSelector="(w) => w.ToString()"
                SortKeySelector="(l) => (int)l">
                <InputGroupStartTemplate>
                    <div class="input-group-text">
                        Log Level
                        <HxPopover Trigger="PopoverTrigger.Hover|PopoverTrigger.Click|PopoverTrigger.Focus"
                                   Title="<b>Log Level</b>"
                                   Content="@LogLevelDocumentation"
                                   Html="true">
                            <HxIcon Icon="@BootstrapIcon.QuestionCircle" style="padding:.5em" />
                        </HxPopover>
                    </div>
                </InputGroupStartTemplate>
            </HxSelect>
        </div>
        <div class="col-3">
            <HxSubmit Color="ThemeColor.Primary" OnClick="UpdateLogLevel">Update</HxSubmit>
        </div>
        <div class="col-3">
        </div>
    </div>
</EditForm>

<div class="row mb-12">
    <HxCard CssClass="mb-12" style="max-width: 100rem;">
        <HeaderTemplate>
            <HxIcon Icon="@BootstrapIcon.Copy" onclick="CopyTextToClipboard"></HxIcon>
        </HeaderTemplate>
        <BodyTemplate>
            <pre>
                @logs.LogText
             </pre>
        </BodyTemplate>
    </HxCard>
</div>

@code {
    private SystemInfoLogsGetResponse logs;

    private ICollection<LogEventLevel> AvailablelogLevels = Enum.GetValues(typeof(LogEventLevel)).Cast<LogEventLevel>().ToList();
    private LogEventLevel currentLogLevel;

    public ClientLogs() : base(nameof(ClientLogs))
    {
        logs = new SystemInfoLogsGetResponse();
    }

    protected override async Task OnInitializedAsync()
    {
        using var tracing = Tracing.ClientTrace($"{nameof(ClientLogs)}.{nameof(OnInitializedAsync)}", kind: ActivityKind.Client);

        logs = await _apiClient.SystemInfoGetLogsAsync();
        var systemInfo = await _apiClient.SystemInfoGetAsync(new SystemInfoGetRequest() { CheckForUpdate = false });

        currentLogLevel = systemInfo.CurrentLogLevel;
    }

    protected async Task UpdateLogLevel()
    {
        using var tracing = Tracing.ClientTrace($"{nameof(ClientLogs)}.{nameof(UpdateLogLevel)}", kind: ActivityKind.Client);
        _toaster.Clear();

        try
        {
            var response = await _apiClient.LogLevelPostAsync(new LogLevelPostRequest() { LogLevel = currentLogLevel });
            currentLogLevel = response.LogLevel;

            _toaster.AddInformation("Log Level Updated!");
        }
        catch (FlurlHttpException e) when (e.StatusCode is StatusCodes.Status400BadRequest)
        {
            var error = await e.GetResponseJsonAsync<ErrorResponse>();
            _toaster.AddError(error.Message);
        }
        catch (Exception e)
        {
            _toaster.AddError($"Failed to update Log Level - {e.Message} - See logs for details.");
            Log.Error("UI - Failed to update Log Level.", e);
        }
    }

    protected async Task CopyTextToClipboard()
    {
        await JS.InvokeVoidAsync("clipboardCopy.copyText", logs.LogText);
    }

    private string LogLevelDocumentation => $"Temporarily change the log level. Note this setting will reset on application restart.<br /><br /><small>(click the <b>?</b> to pin this window)</small>";
}
