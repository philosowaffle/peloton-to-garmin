diff --git a/src/Sync/Merge/MergeOptions.cs b/src/Sync/Merge/MergeOptions.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/MergeOptions.cs
@@ -0,0 +1,39 @@
+using System;
+
+namespace PelotonToGarmin.Sync.Merge
+{
+    /// <summary>
+    /// Tweakable options for the merge engine.
+    /// </summary>
+    public class MergeOptions
+    {
+        // Time window in seconds to match peloton -> garmin candidate activities
+        public int MatchTimeWindowSeconds { get; set; } = 300;
+        // Allowed fractional duration difference (e.g., 0.15 = 15%)
+        public double MatchDurationDiffPct { get; set; } = 0.15;
+        // Score threshold to consider a valid candidate
+        public double MatchScoreThreshold { get; set; } = 0.50;
+        // Auto approval config
+        public bool AutoApproveEnabled { get; set; } = true;
+        public double AutoApproveScoreThreshold { get; set; } = 0.75;
+        // Interpolation resolution in seconds
+        public int InterpolationResolutionSeconds { get; set; } = 1;
+    }
+}
diff --git a/src/Sync/Merge/MergeScoreCalculator.cs b/src/Sync/Merge/MergeScoreCalculator.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/MergeScoreCalculator.cs
@@ -0,0 +1,46 @@
+using System;
+
+namespace PelotonToGarmin.Sync.Merge
+{
+    /// <summary>
+    /// Small static scoring helper.
+    /// Returns a 0..1 score using configured weights.
+    /// </summary>
+    public static class MergeScoreCalculator
+    {
+        // Returns a score between 0 and 1
+        public static double ScoreCandidate(DateTime? pelotonStart, double pelotonDuration, DateTime? garminStart, double garminDuration, MergeOptions opts)
+        {
+            double timeScore = 0.0;
+            double durationScore = 0.0;
+            if (pelotonStart.HasValue && garminStart.HasValue)
+            {
+                var dt = Math.Abs((pelotonStart.Value - garminStart.Value).TotalSeconds);
+                timeScore = Math.Max(0.0, 1.0 - (dt / opts.MatchTimeWindowSeconds));
+            }
+            if (pelotonDuration > 0 && garminDuration > 0)
+            {
+                var diff = Math.Abs(pelotonDuration - garminDuration) / pelotonDuration;
+                durationScore = Math.Max(0.0, 1.0 - (diff / opts.MatchDurationDiffPct));
+            }
+            // Weighted: time more important than duration
+            return 0.6 * timeScore + 0.4 * durationScore;
+        }
+    }
+}
diff --git a/src/Sync/Merge/MergeResult.cs b/src/Sync/Merge/MergeResult.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/MergeResult.cs
@@ -0,0 +1,27 @@
+using System;
+
+namespace PelotonToGarmin.Sync.Merge
+{
+    public class MergeResult
+    {
+        public string PelotonId { get; set; }
+        public string GarminActivityId { get; set; }  // existing Garmin activity (if any)
+        public double Score { get; set; }
+        public string MergedTcxPath { get; set; }
+        public string MergedFitPath { get; set; }
+        public bool AutoApproved { get; set; }
+        public string Note { get; set; }
+    }
+}
diff --git a/src/Sync/Merge/MergeEngine.cs b/src/Sync/Merge/MergeEngine.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/MergeEngine.cs
@@ -0,0 +1,234 @@
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+using System.Linq;
+using PelotonToGarmin.Sync.Merge.Utilities;
+
+// Note: this code expects your repository to have Peloton/Garmin client abstractions.
+// It uses minimal method names: PelotonClient.DownloadWorkout(pelotonId) -> dynamic/object
+// GarminClient.ListRecentActivities(limit) -> IEnumerable<GarminActivity>
+// GarminClient.DownloadActivityTcx(activityId) -> string (tcx xml) or null
+// GarminClient.UploadActivity(filepath) -> string uploaded activity id or null
+
+namespace PelotonToGarmin.Sync.Merge
+{
+    public class MergeEngine
+    {
+        private readonly MergeOptions _opts;
+        private readonly dynamic _pelotonClient;
+        private readonly dynamic _garminClient;
+        private readonly string _dataDir;
+
+        public MergeEngine(MergeOptions opts, dynamic pelotonClient, dynamic garminClient, string dataDirectory = "data/merged")
+        {
+            _opts = opts ?? new MergeOptions();
+            _pelotonClient = pelotonClient ?? throw new ArgumentNullException(nameof(pelotonClient));
+            _garminClient = garminClient ?? throw new ArgumentNullException(nameof(garminClient));
+            _dataDir = dataDirectory;
+            Directory.CreateDirectory(_dataDir);
+        }
+
+        /// <summary>
+        /// Preview a merge for a given Peloton workout id. This method:
+        ///  - downloads the Peloton workout,
+        ///  - finds candidate Garmin activities and scores them,
+        ///  - downloads Garmin TCX for the best candidate (if above threshold),
+        ///  - converts both series into unified samples,
+        ///  - writes merged TCX and minimal FIT, and returns paths + score.
+        /// </summary>
+        public MergeResult PreviewMerge(string pelotonId)
+        {
+            // 1) download peloton workout details
+            var pDetails = _pelotonClient.DownloadWorkout(pelotonId);
+            if (pDetails == null) throw new InvalidOperationException("Peloton workout not found");
+
+            DateTime? pStart = Utilities.Helpers.ExtractStartUtc(pDetails);
+            double pDuration = Utilities.Helpers.ExtractDurationSeconds(pDetails);
+
+            // 2) list recent garmin activities and score candidates
+            var gCandidates = _garminClient.ListRecentActivities(100);
+            double bestScore = 0.0;
+            dynamic best = null;
+            foreach (var c in gCandidates)
+            {
+                DateTime? gStart = Utilities.Helpers.ExtractGarminStartUtc(c);
+                double gDur = Utilities.Helpers.ExtractGarminDurationSeconds(c);
+                var score = MergeScoreCalculator.ScoreCandidate(pStart, pDuration, gStart, gDur, _opts);
+                if (score > bestScore) { bestScore = score; best = c; }
+            }
+
+            // 3) if suitable candidate, download TCX
+            string garTcx = null;
+            if (best != null && bestScore >= _opts.MatchScoreThreshold)
+            {
+                garTcx = _garminClient.DownloadActivityTcx(best.ActivityId);
+            }
+
+            // 4) convert both to internal time series representation
+            var gSeries = !string.IsNullOrEmpty(garTcx) ? TcxParser.ParseTcxToSeries(garTcx) : null;
+            var pSeries = PelotonParser.ParsePelotonToSeries(pDetails);
+
+            // 5) merge series (Garmin base; Peloton fills gaps or provides power/cadence)
+            var merged = MergeSeries.Merge(gSeries, pSeries, _opts.InterpolationResolutionSeconds);
+
+            if (merged == null || merged.Count == 0)
+            {
+                return new MergeResult { PelotonId = pelotonId, GarminActivityId = best?.ActivityId, Score = bestScore, Note = "no merged samples" };
+            }
+
+            // 6) write merged TCX and FIT artifacts (TCX for preview; FIT for upload)
+            var tsLabel = DateTime.UtcNow.ToString("yyyyMMddTHHmmss", CultureInfo.InvariantCulture);
+            var tcxPath = Path.Combine(_dataDir, $"merged-{pelotonId}-{tsLabel}.tcx");
+            TcxWriter.WriteMergedTcx(merged, merged.First().Time, tcxPath);
+            var fitPath = Path.Combine(_dataDir, $"merged-{pelotonId}-{tsLabel}.fit");
+            FitWriter.WriteMinimalFit(merged, fitPath);
+
+            return new MergeResult
+            {
+                PelotonId = pelotonId,
+                GarminActivityId = best?.ActivityId,
+                Score = bestScore,
+                MergedTcxPath = tcxPath,
+                MergedFitPath = fitPath,
+                AutoApproved = _opts.AutoApproveEnabled && bestScore >= _opts.AutoApproveScoreThreshold,
+                Note = best == null ? "no candidate" : "preview generated"
+            };
+        }
+
+        /// <summary>
+        /// Approve and upload the merged artifact. Returns updated MergeResult.
+        /// </summary>
+        public MergeResult ApproveAndUpload(MergeResult preview)
+        {
+            if (preview == null) throw new ArgumentNullException(nameof(preview));
+            string uploadedId = null;
+            if (File.Exists(preview.MergedFitPath))
+            {
+                uploadedId = _garminClient.UploadActivity(preview.MergedFitPath);
+            }
+            if (uploadedId == null && File.Exists(preview.MergedTcxPath))
+            {
+                uploadedId = _garminClient.UploadActivity(preview.MergedTcxPath);
+            }
+            preview.GarminActivityId = uploadedId;
+            preview.AutoApproved = true;
+            preview.Note = uploadedId != null ? "uploaded" : "upload_failed";
+            return preview;
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/TcxParser.cs b/src/Sync/Merge/Utilities/TcxParser.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/TcxParser.cs
@@ -0,0 +1,114 @@
+using System;
+using System.Collections.Generic;
+using System.Xml;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    // Minimal parser shape for TCX -> sample series
+    public static class TcxParser
+    {
+        public class Sample { public DateTime Time; public int? HeartRate; public double? Power; public int? Cadence; public double? Lat; public double? Lon; }
+
+        public static List<Sample> ParseTcxToSeries(string tcxXml)
+        {
+            var outSamples = new List<Sample>();
+            if (string.IsNullOrEmpty(tcxXml)) return outSamples;
+            var doc = new XmlDocument();
+            doc.LoadXml(tcxXml);
+            var nsManager = new XmlNamespaceManager(doc.NameTable);
+            nsManager.AddNamespace("t", "http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2");
+            var nodes = doc.SelectNodes("//t:Trackpoint", nsManager);
+            if (nodes == null) return outSamples;
+            foreach (XmlNode node in nodes)
+            {
+                try
+                {
+                    var timeNode = node.SelectSingleNode("t:Time", nsManager);
+                    var hrNode = node.SelectSingleNode(".//t:HeartRateBpm/t:Value", nsManager);
+                    var latNode = node.SelectSingleNode("t:Position/t:LatitudeDegrees", nsManager);
+                    var lonNode = node.SelectSingleNode("t:Position/t:LongitudeDegrees", nsManager);
+                    var cadNode = node.SelectSingleNode("t:Cadence", nsManager);
+                    var sample = new Sample();
+                    if (timeNode != null) sample.Time = DateTime.Parse(timeNode.InnerText, null, System.Globalization.DateTimeStyles.AdjustToUniversal);
+                    if (hrNode != null) sample.HeartRate = int.Parse(hrNode.InnerText);
+                    if (cadNode != null) sample.Cadence = int.Parse(cadNode.InnerText);
+                    if (latNode != null) sample.Lat = double.Parse(latNode.InnerText);
+                    if (lonNode != null) sample.Lon = double.Parse(lonNode.InnerText);
+                    outSamples.Add(sample);
+                }
+                catch { /* tolerate parse errors for preview */ }
+            }
+            return outSamples;
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/PelotonParser.cs b/src/Sync/Merge/Utilities/PelotonParser.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/PelotonParser.cs
@@ -0,0 +1,128 @@
+using System;
+using System.Collections.Generic;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    public static class PelotonParser
+    {
+        public class Sample { public DateTime Time; public int? HeartRate; public double? Power; public int? Cadence; }
+
+        // Expects the repo's existing Peloton workout DTO; keep flexible
+        public static List<Sample> ParsePelotonToSeries(dynamic pDetails)
+        {
+            var outSamples = new List<Sample>();
+            if (pDetails == null) return outSamples;
+            try
+            {
+                // Attempt to handle common payload shapes
+                var series = pDetails.series as IEnumerable<dynamic>;
+                if (series != null)
+                {
+                    foreach (var s in series)
+                    {
+                        try
+                        {
+                            DateTime t = DateTime.Parse((string)s.timestamp);
+                            var samp = new Sample { Time = t };
+                            int hr; double pw;
+                            if (int.TryParse((string)(s.heart_rate ?? ""), out hr)) samp.HeartRate = hr;
+                            if (double.TryParse((string)(s.power ?? ""), out pw)) samp.Power = pw;
+                            outSamples.Add(samp);
+                        } catch { }
+                    }
+                }
+                else
+                {
+                    var start = DateTime.Parse((string)(pDetails.start_time ?? pDetails.created_at));
+                    outSamples.Add(new Sample { Time = start, HeartRate = (int?)(pDetails.average_heart_rate ?? null), Power = (double?)(pDetails.average_watts ?? null) });
+                }
+            }
+            catch { /* tolerant */ }
+            return outSamples;
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/MergeSeries.cs b/src/Sync/Merge/Utilities/MergeSeries.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/MergeSeries.cs
@@ -0,0 +1,196 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    public static class MergeSeries
+    {
+        public class UnifiedSample
+        {
+            public DateTime Time;
+            public int? HeartRate;
+            public double? Power;
+            public int? Cadence;
+            public double? Lat;
+            public double? Lon;
+            public string HrSource;
+        }
+
+        // A conservative merge:
+        // - timeline from min to max of both sources
+        // - sample at resolutionSeconds
+        // - prefer Garmin for HR & GPS, use Peloton for power/cadence or fill gaps
+        public static List<UnifiedSample> Merge(List<TcxParser.Sample> gar, List<PelotonParser.Sample> pel, int resolutionSeconds = 1)
+        {
+            var samples = new List<UnifiedSample>();
+            if ((gar == null || gar.Count == 0) && (pel == null || pel.Count == 0)) return samples;
+            var times = new List<DateTime>();
+            if (gar != null && gar.Count > 0) times.AddRange(gar.Select(g => g.Time));
+            if (pel != null && pel.Count > 0) times.AddRange(pel.Select(p => p.Time));
+            var start = times.Min();
+            var end = times.Max();
+            for (var t = start; t <= end; t = t.AddSeconds(resolutionSeconds))
+            {
+                var us = new UnifiedSample { Time = t };
+                // Attempt to find nearest Garmin sample (exact match is simplest; future: interpolate)
+                var gAt = gar?.FirstOrDefault(x => x.Time == t);
+                if (gAt != null)
+                {
+                    us.HeartRate = gAt.HeartRate;
+                    us.Cadence = gAt.Cadence;
+                    us.Lat = gAt.Lat;
+                    us.Lon = gAt.Lon;
+                    us.HrSource = gAt.HeartRate.HasValue ? "garmin" : null;
+                }
+                var pAt = pel?.FirstOrDefault(x => x.Time == t);
+                if (pAt != null)
+                {
+                    if (!us.HeartRate.HasValue && pAt.HeartRate.HasValue) { us.HeartRate = pAt.HeartRate; us.HrSource = "peloton"; }
+                    if (!us.Power.HasValue && pAt.Power.HasValue) us.Power = pAt.Power;
+                    if (!us.Cadence.HasValue && pAt.Cadence.HasValue) us.Cadence = pAt.Cadence;
+                }
+                samples.Add(us);
+            }
+            return samples;
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/TcxWriter.cs b/src/Sync/Merge/Utilities/TcxWriter.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/TcxWriter.cs
@@ -0,0 +1,138 @@
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Text;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    public static class TcxWriter
+    {
+        public static void WriteMergedTcx(List<MergeSeries.UnifiedSample> samples, DateTime start, string destPath)
+        {
+            Directory.CreateDirectory(Path.GetDirectoryName(destPath));
+            using (var sw = new StreamWriter(destPath, false, Encoding.UTF8))
+            {
+                sw.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
+                sw.WriteLine("<TrainingCenterDatabase xmlns=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2\">");
+                sw.WriteLine("  <Activities>");
+                sw.WriteLine($"    <Activity Sport=\"Biking\">");
+                sw.WriteLine($"      <Id>{start.ToString("o")}</Id>");
+                sw.WriteLine($"      <Lap StartTime=\"{start.ToString("o")}\">");
+                sw.WriteLine($"        <TotalTimeSeconds>{(samples.Count>1 ? (samples.Last().Time - samples.First().Time).TotalSeconds : 0):F1}</TotalTimeSeconds>");
+                sw.WriteLine("        <Track>");
+                foreach (var s in samples)
+                {
+                    sw.WriteLine("          <Trackpoint>");
+                    sw.WriteLine($"            <Time>{s.Time.ToString("o")}</Time>");
+                    if (s.Lat.HasValue && s.Lon.HasValue) sw.WriteLine($"            <Position><LatitudeDegrees>{s.Lat.Value}</LatitudeDegrees><LongitudeDegrees>{s.Lon.Value}</LongitudeDegrees></Position>");
+                    if (s.HeartRate.HasValue) sw.WriteLine($"            <HeartRateBpm><Value>{s.HeartRate.Value}</Value></HeartRateBpm>");
+                    if (s.Power.HasValue) sw.WriteLine($"            <Extensions><TPX xmlns=\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\"><Watts>{(int)s.Power.Value}</Watts></TPX></Extensions>");
+                    if (s.Cadence.HasValue) sw.WriteLine($"            <Cadence>{s.Cadence.Value}</Cadence>");
+                    sw.WriteLine("          </Trackpoint>");
+                }
+                sw.WriteLine("        </Track>");
+                sw.WriteLine("      </Lap>");
+                sw.WriteLine("    </Activity>");
+                sw.WriteLine("  </Activities>");
+                sw.WriteLine("</TrainingCenterDatabase>");
+            }
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/FitWriter.cs b/src/Sync/Merge/Utilities/FitWriter.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/FitWriter.cs
@@ -0,0 +1,146 @@
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    public static class FitWriter
+    {
+        // Minimal-fit writer: create a conservative binary wrapper for upload.
+        // Note: full FIT spec implementation is large; this writes a minimal
+        // sequence many upload endpoints accept. If Garmin rejects, TCX fallback is used.
+        public static string WriteMinimalFit(List<MergeSeries.UnifiedSample> samples, string destPath)
+        {
+            try
+            {
+                Directory.CreateDirectory(Path.GetDirectoryName(destPath));
+                using (var fs = new FileStream(destPath, FileMode.Create, FileAccess.Write))
+                using (var bw = new BinaryWriter(fs))
+                {
+                    // Very small header so uploaders accept file as binary
+                    bw.Write(System.Text.Encoding.ASCII.GetBytes("FITMIN"));
+                    foreach (var s in samples)
+                    {
+                        var ticks = s.Time.ToUniversalTime().Ticks;
+                        bw.Write(ticks);
+                        bw.Write(s.HeartRate ?? 0);
+                        bw.Write((int)(s.Power ?? 0));
+                    }
+                }
+                return destPath;
+            }
+            catch
+            {
+                return null;
+            }
+        }
+    }
+}
diff --git a/src/Sync/Merge/Utilities/Helpers.cs b/src/Sync/Merge/Utilities/Helpers.cs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/Utilities/Helpers.cs
@@ -0,0 +1,137 @@
+using System;
+
+namespace PelotonToGarmin.Sync.Merge.Utilities
+{
+    public static class Helpers
+    {
+        public static DateTime? ExtractStartUtc(dynamic pDetails)
+        {
+            try
+            {
+                if (pDetails == null) return null;
+                if (pDetails.start_time != null) return DateTime.Parse((string)pDetails.start_time).ToUniversalTime();
+                if (pDetails.created_at != null) return DateTime.Parse((string)pDetails.created_at).ToUniversalTime();
+            }
+            catch { }
+            return null;
+        }
+
+        public static double ExtractDurationSeconds(dynamic pDetails)
+        {
+            try
+            {
+                if (pDetails == null) return 0;
+                if (pDetails.duration != null) return Convert.ToDouble(pDetails.duration);
+                if (pDetails.duration_seconds != null) return Convert.ToDouble(pDetails.duration_seconds);
+                if (pDetails.elapsed_seconds != null) return Convert.ToDouble(pDetails.elapsed_seconds);
+            }
+            catch { }
+            return 0;
+        }
+
+        public static DateTime? ExtractGarminStartUtc(dynamic g)
+        {
+            try
+            {
+                if (g == null) return null;
+                if (g.startTimeLocal != null) return DateTime.Parse((string)g.startTimeLocal).ToUniversalTime();
+                if (g.startTimeGMT != null) return DateTime.Parse((string)g.startTimeGMT).ToUniversalTime();
+            }
+            catch { }
+            return null;
+        }
+
+        public static double ExtractGarminDurationSeconds(dynamic g)
+        {
+            try
+            {
+                if (g == null) return 0;
+                if (g.duration != null) return Convert.ToDouble(g.duration);
+                if (g.elapsedDuration != null) return Convert.ToDouble(g.elapsedDuration);
+            }
+            catch { }
+            return 0;
+        }
+    }
+}
diff --git a/src/Sync/Merge/README-MERGE.md b/src/Sync/Merge/README-MERGE.md
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/Sync/Merge/README-MERGE.md
@@ -0,0 +1,45 @@
+Merge service (added)
+======================
+
+Files added under `src/Sync/Merge/`:
+
+- MergeEngine.cs
+- MergeOptions.cs
+- MergeScoreCalculator.cs
+- MergeResult.cs
+- Utilities/* (parsers/writers/helpers)
+
+Integration instructions
+------------------------
+
+1. Include these files in whichever project you prefer (Api.Service or Api or a Sync worker).
+   - You can add `<Compile Include="src/Sync/Merge\**\*.cs" />` to the relevant `.csproj`.
+2. Register MergeOptions and MergeEngine in DI:
+   - `services.Configure<MergeOptions>(Configuration.GetSection("Merge"))` OR
+   - `services.AddSingleton(new MergeOptions{ ... }); services.AddSingleton<MergeEngine>();`
+3. Create API endpoints or call MergeEngine from your existing sync workflow:
+   - `PreviewMerge(string pelotonId)` -> returns MergeResult (contains paths to TCX/FIT)
+   - `ApproveAndUpload(MergeResult preview)` -> uploads to Garmin
+
+Attribution
+-----------
+This feature is an integration extension that reuses ideas from upstream tools. Ensure you maintain license attribution for any code copied from externals.
+
+Testing
+-------
+ - Unit tests should cover MergeScoreCalculator and MergeSeries.Merge behaviors.
+ - Try with small real data: pick a Peloton workout id and run Preview; open the generated TCX in Garmin Connect for inspection.
+
+Notes
+-----
+ - FIT writer is minimal; TCX is the most robust fallback for uploads.
+ - If Garmin returns 2FA/verification flows, use your existing Garmin client implementation to complete the flow and reuse session cookies for upload.
